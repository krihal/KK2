//**************************************************************************/
/*! 
    @file     ST7565.c
    @author   K. Townsend (microBuilder.eu)
    @date     22 March 2010
    @version  0.10

    @section DESCRIPTION

    Driver for 128x64 pixel display based on the ST7565 LCD controller.

    This driver is based on the ST7565 Library from Limor Fried
    (Adafruit Industries) at: http://github.com/adafruit/ST7565-LCD/    
    
    @section LICENSE

    Software License Agreement (BSD License)

    Copyright (c) 2010, microBuilder SARL
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
    3. Neither the name of the copyright holders nor the
    names of its contributors may be used to endorse or promote products
    derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**************************************************************************/
#include <string.h>
#include <util/delay.h>
#include <avr/pgmspace.h> 

#include "st7565.h"
#include "fonts.h"
#include "io_cfg.h"
//#include "logo.h"

//#include "core/gpio/gpio.h"
//#include "core/systick/systick.h"
//#include "drivers/lcd/smallfonts.h"

static FONT_DEF_STRUCT * currentFont;
static st7565drawmode_t currentDrawMode = DM_NORMAL;		// default to Normal



void sendByte(uint8_t byte);

#define nop() asm volatile("nop");

#define CMD(c)        do { ST7565_A0 = 0; sendByte( c ); } while (0);
#define DATA(d)       do { ST7565_A0 = 1; sendByte( d ); } while (0);
//#define DELAY(mS)     do { systickDelay( mS / CFG_SYSTICK_DELAY_IN_MS ); } while(0);

// http://en.radzio.dxp.pl/bitmap_converter/

#define BUFFER_SIZE (128*64/8)
uint8_t buffer[BUFFER_SIZE] ={

    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0xDF, 0xFF, 0xE7, 0xFE, 0xF8, 0xE0, 0xE0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF8, 0xB8, 0xB8, 0xB8, 0x3C, 0xFC, 0xFC, 0xFE, 0xFE, 0x3E, 0x2F, 0x4F, 0x7E, 0x38,
    0xF0, 0x70, 0x78, 0x1C, 0x0E, 0x06, 0x06, 0x06, 0x16, 0x17, 0x1E, 0x1C, 0x38, 0x70, 0xC0, 0x80,
    0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC3, 0x43, 0x6F, 0x7F, 0x7F, 0x3F, 0x3F,
    0x03, 0x01, 0x01, 0x01, 0x01, 0x13, 0x31, 0x60, 0xE0, 0xC3, 0xE3, 0xF3, 0xF0, 0x60, 0x78, 0x3F,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xC0,
    0xC0, 0x61, 0x67, 0xE6, 0x83, 0xC3, 0xE3, 0xFE, 0xFC, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x78, 0x0D, 0x0F, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x80, 0x80, 0xC0, 0xC0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x26, 0x22, 0x27, 0x37, 0x37, 0x3F, 0x3F, 0x4C, 0x4C,
    0x58, 0x18, 0x30, 0xE1, 0xC1, 0x81, 0xFD, 0xCD, 0x07, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE0, 0xE0, 0xE0, 0x3C, 0x3C, 0x04, 0x06, 0x06, 0x06, 0x03, 0xE3,
    0x79, 0x1D, 0x46, 0x43, 0x39, 0x19, 0x08, 0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0xD0, 0xD0, 0xD0,
    0xF8, 0xF8, 0xE8, 0xE4, 0x7C, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFC, 0xCC, 0xDC, 0x8C, 0x9C, 0x1C,
    0xFC, 0x86, 0x06, 0x07, 0x1F, 0x3F, 0x7F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x0E, 0x1C, 0x70, 0xC0, 0xFF,
    0xF8, 0x30, 0x18, 0x1C, 0x3C, 0xEE, 0xC7, 0x07, 0x07, 0x41, 0x47, 0x9F, 0xFF, 0xFF, 0xE7, 0xE7,
    0x7F, 0xF1, 0xE1, 0xE1, 0x70, 0x71, 0xFF, 0xFF, 0x7F, 0x0F, 0x0F, 0xFF, 0xF8, 0xC7, 0xBD, 0x78,
    0x63, 0xFF, 0xFC, 0xC6, 0x86, 0x06, 0x07, 0x03, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xE0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
    0xCF, 0xFC, 0xB8, 0xF8, 0x9C, 0x8C, 0x8D, 0x0F, 0x0E, 0x7E, 0xE0, 0xF9, 0xB7, 0x8F, 0x8F, 0x9F,
    0x9F, 0xBC, 0xBD, 0xFD, 0xFC, 0xE4, 0x21, 0x1E, 0xFE, 0xF3, 0xFB, 0x6D, 0x76, 0x33, 0x39, 0x18,
    0x0C, 0x0C, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x03, 0x0F, 0x1D, 0x1D, 0x1D, 0x1F, 0x0E, 0x06, 0x06, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x1F, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xFC, 0xFC, 0xC0, 0xE0, 0xF0, 0xBC, 0x1C, 0x0C, 0xF0,
    0xF8, 0x1C, 0x0C, 0x0C, 0x0C, 0x1C, 0x98, 0x00, 0x0C, 0xFC, 0xFC, 0xC0, 0xC0, 0xFC, 0xFC, 0x0C,
    0x00, 0x00, 0x18, 0xBC, 0xAC, 0xAC, 0xA8, 0xFC, 0xFC, 0x0C, 0x00, 0x70, 0xF8, 0xDC, 0x8C, 0x8C,
    0x8C, 0xDC, 0xD8, 0x00, 0x0C, 0xFC, 0xFC, 0x20, 0x74, 0xFC, 0x9C, 0x8C, 0x00, 0x70, 0xF8, 0xAC,
    0xAC, 0xAC, 0xAC, 0xEC, 0x68, 0x00, 0x8C, 0xFC, 0xFC, 0x8C, 0x8C, 0x80, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x07, 0x07, 0x06, 0x06, 0x06, 0x07, 0x03, 0x00, 0x01,
    0x03, 0x07, 0x06, 0x06, 0x06, 0x07, 0x07, 0x00, 0x06, 0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
    0x01, 0x00, 0x01, 0x00, 0x0C, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00


};

#define CHECKBIT(ADDRESS,BIT) ((uint32_t)(ADDRESS & (1<<BIT)))

//static void drawChar(uint16_t x, uint16_t y, uint8_t c, FONT_DEF_STRUCT * font);

/**************************************************************************/
/* Private Methods                                                        */
/**************************************************************************/

/**************************************************************************/
/*! 
    @brief Renders the buffer contents

    @param[in]  buffer
                Pointer to the buffer containing the raw pixel data
*/
/**************************************************************************/
void writeBuffer(uint8_t *buffer) 
{
  uint8_t c, p;

  for(p = 0; p < 8; p++) 
  {
    CMD(ST7565_CMD_SET_PAGE | (7-p));
//    CMD(ST7565_CMD_SET_PAGE | (p));
      CMD(ST7565_CMD_SET_COLUMN_LOWER | (0x0 & 0xf));
    CMD(ST7565_CMD_SET_COLUMN_UPPER | ((0x0 >> 4) & 0xf));
    CMD(ST7565_CMD_RMW);
    
    for(c = 0; c < 128; c++) 
    {
      DATA(buffer[(128*p)+c]);
    }
  }
}

/**************************************************************************/
/*! 
    @brief Simulates an SPI write using GPIO

    @param[in]  byte
                The byte to send
*/
/**************************************************************************/
void sendByte(uint8_t byte)
{
  int8_t i;

  // Make sure clock pin starts high
  ST7565_SCL = 1;

  // Write from MSB to LSB
  for (i=7; i>=0; i--) 
  {
		ST7565_SCL = 0;
		nop();nop();
		ST7565_SDA = (byte & (1 << i) ? 1 : 0);
    ST7565_SCL = 1;
  }
}

/**************************************************************************/
/*!
    @brief  Draws a single graphic character using the supplied font
*/
/**************************************************************************/

void st7565DrawChar(uint16_t x, uint16_t y, uint8_t c )
{
  uint8_t bpc, b;
	uint8_t bytesPerChar = ( (currentFont->Height-1) / 8 + 1 );	// calc how many bytes we need to read

  // Render each column
  uint16_t xoffset, yoffset;
  for (xoffset = 0; xoffset < currentFont->Width; xoffset++)
  {
		for (bpc = 0; bpc < bytesPerChar; bpc++)
		{

    	b = pgm_read_byte(&currentFont->FontTable[((c - currentFont->FirstChar) * currentFont->Width * bytesPerChar) + (xoffset*bytesPerChar)+bytesPerChar-bpc-1]); 

	    // not super-happy with this, but it works....	
	    for (yoffset = 0; yoffset < currentFont->Height; yoffset++)
	    {
				if (yoffset/8 == bpc && CHECKBIT(b , yoffset%8))
				{
	        st7565DrawPixel(x + xoffset, y + yoffset);
	      }
	    }
		}
  }
}


/**************************************************************************/
/* Public Methods                                                         */
/**************************************************************************/

/**************************************************************************/
/*! 
    @brief Initialises the ST7565 LCD display
*/
/**************************************************************************/
void st7565Init(FONT_DEF_STRUCT * font)
{
  // Note: This can be optimised to set all pins to output and high
  // in two commands by manipulating the registers directly (assuming
  // that the pins are located in the same GPIO bank).  The code is left
  // as is for clarity sake in case the pins are not all located in the
  // same bank.

	ST7565_CS_DIR	 		= OUTPUT;
	ST7565_RST_DIR	 	= OUTPUT;
	ST7565_A0_DIR	 		= OUTPUT;
	ST7565_SCL_DIR	 	= OUTPUT;
	ST7565_SDA_DIR	 	= OUTPUT;

	ST7565_SDA = 1;
  ST7565_SCL = 1;
	ST7565_A0  = 1;
	ST7565_RST = 1;
	ST7565_CS  = 1;

  // Reset
	ST7565_CS  = 0;
	ST7565_RST = 0;
	_delay_ms(500);
	ST7565_RST = 1;

	currentFont = font;

  // Configure Display
  //CMD(ST7565_CMD_SET_BIAS_7);                         // LCD Bias Select									0xA3		0xA2
  CMD(ST7565_CMD_SET_BIAS_9);                         // LCD Bias Select									0xA3		0xA2
  CMD(ST7565_CMD_SET_ADC_NORMAL);                     // ADC Select												0xA0		0xA6
  CMD(ST7565_CMD_SET_COM_NORMAL);                     // SHL Select												0xC0		0xc8
  //CMD(ST7565_CMD_SET_COM_REVERSE);                     // SHL Select												0xC0		0xc8
  CMD(ST7565_CMD_SET_DISP_START_LINE);                // Initial Display Line							0x40		0x40
  CMD(ST7565_CMD_SET_POWER_CONTROL | 0x04);           // Turn on voltage converter (VC=1, VR=0, VF=0)			0x28		0x24
  _delay_ms(50);                											// Wait 50mS
  CMD(ST7565_CMD_SET_POWER_CONTROL | 0x06);           // Turn on voltage regulator (VC=1, VR=1, VF=0)
  _delay_ms(50);                											// Wait 50mS
  CMD(ST7565_CMD_SET_POWER_CONTROL | 0x07);           // Turn on voltage follower
  _delay_ms(10);                											// Wait 10mS
  CMD(ST7565_CMD_SET_RESISTOR_RATIO | 0x6);           // Set LCD operating voltage

  // Turn display on
  CMD(ST7565_CMD_DISPLAY_ON);													// 0xAF
  CMD(ST7565_CMD_SET_ALLPTS_NORMAL);									// 0xA4
  st7565SetBrightness(0x11);	// 0x18
}


/**************************************************************************/
/*! 
    @brief Sets the display brightness
*/
/**************************************************************************/
void st7565SetBrightness(uint8_t val)
{
  CMD(ST7565_CMD_SET_VOLUME_FIRST);
  CMD(ST7565_CMD_SET_VOLUME_SECOND | (val & 0x3f));
}

/**************************************************************************/
/*! 
    @brief Clears the screen
*/
/**************************************************************************/
/* Doesn't work !
void st7565ClearScreen(void) 
{
  uint8_t p, c;
  
  for(p = 0; p < 8; p++) 
  {
    CMD(ST7565_CMD_SET_PAGE | p);
    for(c = 0; c < 129; c++) 
    {
      CMD(ST7565_CMD_SET_COLUMN_LOWER | (c & 0xf));
      CMD(ST7565_CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      DATA(0xC);
    }     
  }
}
*/
void st7565ClearScreen(void) 
{
	st7565ClearBuffer();
	st7565Refresh();
}

/**************************************************************************/
/*! 
    @brief Clears the buffer
*/
/**************************************************************************/

void st7565ClearBuffer( void )
{
	memset(buffer, 0, BUFFER_SIZE);
}
/**************************************************************************/
/*! 
    @brief Renders the contents of the pixel buffer on the LCD
*/
/**************************************************************************/
void st7565Refresh(void)
{
  writeBuffer(buffer);
}



/**************************************************************************/
/*! 
    @brief Draws a single pixel in image buffer

    @param[in]  x
                The x position (0..127)
    @param[in]  y
                The y position (0..63)
*/
/**************************************************************************/
void st7565DrawPixel(uint8_t x, uint8_t y) 
{
  if ((x >= 128) || (y >= 64)) return;

  // x is which column
	switch ( currentDrawMode )
	{
		case DM_REVERSE :
  		buffer[x+ (y/8)*128] &= ~(1 << (7-(y%8)));
			break;

		case DM_INVERT :
  		buffer[x+ (y/8)*128] ^= (1 << (7-(y%8)));
			break;

		default :					// DM_NORMAL
  		buffer[x+ (y/8)*128] |= (1 << (7-(y%8)));
			break;
	}
}

/**************************************************************************/
/*! 
    @brief Clears a single pixel in image buffer

    @param[in]  x
                The x position (0..127)
    @param[in]  y
                The y position (0..63)
*/
/**************************************************************************/
void st7565ClearPixel(uint8_t x, uint8_t y)
{
  if ((x >= 128) || (y >= 64))  return;

	if (currentDrawMode == DM_INVERT) return;

  // x is which column
  buffer[x+ (y/8)*128] &= ~(1 << (7-(y%8)));
}

/**************************************************************************/
/*!
    @brief  Draws a string using the supplied font data.

    @param[in]  x
                Starting x co-ordinate
    @param[in]  y
                Starting y co-ordinate
    @param[in]  text
                The string to render
    @param[in]  font
                Pointer to the FONT_DEF to use when drawing the string

    @section Example

    @code 

    #include "drivers/lcd/bitmap/st7565/st7565.h"
    #include "drivers/lcd/smallfonts.h"
    
    // Configure the pins and initialise the LCD screen
    st7565Init();

    // Enable the backlight
    st7565BLEnable();

    // Render some text on the screen with different fonts
    st7565DrawString(1, 1, "3X6 SYSTEM", Font_System3x6);   // 3x6 is UPPER CASE only
    st7565DrawString(1, 10, "5x8 System", Font_System5x8);
    st7565DrawString(1, 20, "7x8 System", Font_System7x8);

    // Refresh the screen to see the results
    st7565Refresh();

    @endcode
*/
/**************************************************************************/
void st7565DrawString(uint16_t x, uint16_t y, char* text)
{
  uint8_t l;
  for (l = 0; l < strlen(text); l++)
  {
    st7565DrawChar(x + (l * (currentFont->Width + 1)), y, text[l] );
  }
}

void st7565DrawString_P(uint16_t x, uint16_t y, char* text)
{
	char c;
  uint8_t l = 0;
	
	c = pgm_read_byte(text++);
	if (c != 0)
	{
		do {
			st7565DrawChar(x + (l * (currentFont->Width + 1)), y, c );
			c = pgm_read_byte(text++);
			l++;
		} while (c!= 0);
	}
}

void st7565SetFont( FONT_DEF_STRUCT * font )
{
	currentFont = font;
}

void st7565SetDrawMode( st7565drawmode_t drawMode )
{
	if (drawMode > DM_INVERT) return;
	currentDrawMode = drawMode;
}

void st7565DrawLine( uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2 )
{
	int16_t dx, dy, stepx=1, stepy=1, fraction;

	dy = y2 - y1;
	dx = x2 - x1;

	if ( dy < 0 ) {
		dy    = -dy;
		stepy = -1;
	}

	if ( dx < 0 ) {
		dx    = -dx;
		stepx = -1;
	}

	dx <<= 1;
	dy <<= 1;

	st7565DrawPixel( x1, y1 );

	if ( dx > dy )
	{
		fraction = dy - (dx >> 1);
		while ( x1 != x2 )
		{
			if ( fraction >= 0 )
			{
				y1 += stepy;
				fraction -= dx;
			}
			x1 += stepx;
			fraction += dy;
			st7565DrawPixel( x1, y1 );
		}
	} else {
		fraction = dx - (dy >> 1);
		while ( y1 != y2 )
		{
			if ( fraction >= 0 )
			{
				x1 += stepx;
				fraction -= dy;
			}
			y1 += stepy;
			fraction += dx;
			st7565DrawPixel( x1, y1 );
		}
	}
}
// 9902 -> 9774
//st7565DrawRect( 5, 25, 64, 40 );
void st7565DrawRect( uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2 )
{
	uint8_t y;

	for ( y=y1; y<=y2; y++ )
	{
		st7565DrawLine( x1, y, x2, y );
	}
}

void st7565WriteLogo()
{
    
        uint8_t c, p;
        
        for(p = 0; p < 8; p++)
        {
            //    CMD(ST7565_CMD_SET_PAGE | (7-p));
            CMD(ST7565_CMD_SET_PAGE | (p));
            CMD(ST7565_CMD_SET_COLUMN_LOWER | (0x0 & 0xf));
            CMD(ST7565_CMD_SET_COLUMN_UPPER | ((0x0 >> 4) & 0xf));
            CMD(ST7565_CMD_RMW);
            
            for(c = 0; c < 128; c++) 
            {
                DATA(buffer[(128*p)+c]);
            }
        }
    
    
}
